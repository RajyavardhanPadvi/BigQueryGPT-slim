<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>BigQueryGPT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body{font-family:Inter,Arial;background:#071027;color:#e6f7fb;margin:0}
    .wrap{max-width:960px;margin:24px auto;padding:0 16px}
    .hint{color:#9fd6e6;font-size:0.9rem}
    .btn{background:#2ec4ff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .zone{margin-top:14px;border:2px dashed #2ec4ff;padding:18px;border-radius:12px;text-align:center}
    .chat{margin-top:20px;background:#071827;border:1px solid #123245;border-radius:10px;padding:12px}
    .msg{margin:8px 0;padding:8px;border-radius:8px;max-width:80%}
    .user{margin-left:auto;background:#0e2f4a}
    .bot{margin-right:auto;background:#0b1f33}
    .row{display:flex;gap:8px;align-items:center}
    input[type=text]{flex:1;border-radius:8px;border:1px solid #2b4d66;background:#0b1b2b;color:#e6f7fb;padding:8px}
    pre{white-space:pre-wrap;color:#bfefff}
  </style>
</head>
<body>
<div class="wrap">
  <h2>BigQueryGPT</h2>
  <p class="hint">1) Upload small CSV/TXT/JSON → 2) Build Index → 3) Ask</p>

  <div class="zone" ondrop="dropHandler(event)" ondragover="dragOverHandler(event)" onclick="fileInput.click()">
    Drop/click to select files
    <input id="fileInput" type="file" multiple style="display:none" onchange="uploadFiles(this.files)"/>
  </div>
  <pre id="files" class="hint"></pre>

  <div style="margin-top:8px">
    <button class="btn" onclick="buildIndex()">Build Index</button>
    <span id="buildOut" class="hint"></span>
  </div>

  <div class="chat" id="chatBox">
    <div id="msgs"></div>
    <div class="row" style="margin-top:8px">
      <input id="q" type="text" placeholder="Ask your data..." />
      <button class="btn" onclick="ask()">Ask</button>
    </div>
  </div>
</div>

<script>
// ---------- helpers ----------
function dragOverHandler(e){ e.preventDefault(); }
function dropHandler(e){ e.preventDefault(); uploadFiles(e.dataTransfer.files); }

const filesOut = document.getElementById('files');
const buildOut = document.getElementById('buildOut');
const msgs     = document.getElementById('msgs');
const fileInput= document.getElementById('fileInput');

function addMsg(txt, who) {
  const d = document.createElement('div');
  d.className = 'msg ' + (who==='user' ? 'user' : 'bot');
  d.textContent = txt;
  msgs.appendChild(d);
  msgs.scrollTop = msgs.scrollHeight;
}

async function fetchWithTimeout(url, opts={}, ms=30000) { // default 30s
  const ctl = new AbortController();
  const t = setTimeout(() => ctl.abort(), ms);
  try {
    const res = await fetch(url, { ...opts, signal: ctl.signal });
    clearTimeout(t);
    return res;
  } catch (e) {
    clearTimeout(t);
    throw e;
  }
}

async function fetchJSONWithRetry(url, opts, ms, retries=1) {
  try {
    const r = await fetchWithTimeout(url, opts, ms);
    const txt = await r.text();
    let j; try { j = JSON.parse(txt); } catch { j = { error: txt }; }
    if (!r.ok) throw new Error((j.detail || j.error || ('HTTP '+r.status)));
    return j;
  } catch (e) {
    if (retries > 0) {
      await new Promise(r => setTimeout(r, 1200));
      return fetchJSONWithRetry(url, opts, ms, retries-1);
    }
    throw e;
  }
}

// ---------- UI actions ----------
async function uploadFiles(fs){
  if (!fs || !fs.length) return;
  let fd = new FormData();
  for (let f of fs) fd.append('files', f);

  filesOut.textContent = 'Uploading...';
  try {
    // give upload plenty of time (cold start + file IO)
    const j = await fetchJSONWithRetry('/upload', { method:'POST', body: fd }, 60000, 1);
    filesOut.textContent = j.message || JSON.stringify(j);
  } catch (e) {
    filesOut.textContent = 'Upload failed: ' + (e?.message || e);
  }

  // show what server sees
  try {
    const dbg = await fetchJSONWithRetry('/debug/uploads', {}, 15000, 0);
    if (Array.isArray(dbg.files)) {
      filesOut.textContent += '\nServer sees: ' + (dbg.files.length ? dbg.files.join(', ') : '(none)');
    }
  } catch {}
}

async function buildIndex(){
  buildOut.textContent = "Building...";
  try {
    // 60s build timeout (parsing + TF-IDF)
    const j = await fetchJSONWithRetry('/build_index', {
      method:'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ path: './uploads' })
    }, 60000, 1);
    buildOut.textContent = j.status ? `Index ready (${j.n_docs} docs)` : (j.detail || JSON.stringify(j));
  } catch (e) {
    buildOut.textContent = 'Build error: ' + (e?.message || e);
  }
}

async function ask(){
  const q = document.getElementById('q').value.trim();
  if(!q) return;
  addMsg(q, 'user');
  addMsg('Thinking...', 'bot');
  try {
    const j = await fetchJSONWithRetry('/ask?q=' + encodeURIComponent(q) + '&fast=1', {}, 30000, 0);
    const a = j.answer;
    msgs.lastChild.textContent = (typeof a === 'string') ? a : JSON.stringify(a, null, 2);
  } catch (e) {
    msgs.lastChild.textContent = 'Ask failed: ' + (e?.message || e);
  }
}

// convenience: on load, show server-side files if any
(async () => {
  try {
    const j = await fetchJSONWithRetry('/debug/uploads', {}, 15000, 0);
    if (Array.isArray(j.files) && j.files.length) {
      filesOut.textContent = `Server sees ${j.files.length} file(s): ` + j.files.join(', ');
    }
  } catch {}
})();
</script>
</body>
</html>
